<!DOCTYPE html>

<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transcriptor de Audio Avanzado</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
    }

    .container {
        max-width: 1200px;
        margin: 0 auto;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        overflow: hidden;
    }

    .header {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 30px;
        text-align: center;
    }

    .header h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        font-weight: 700;
    }

    .header p {
        font-size: 1.1rem;
        opacity: 0.9;
    }

    .content {
        padding: 40px;
    }

    .upload-section {
        background: #f8f9ff;
        border: 3px dashed #667eea;
        border-radius: 15px;
        padding: 40px;
        text-align: center;
        margin-bottom: 30px;
        transition: all 0.3s ease;
        cursor: pointer;
    }

    .upload-section:hover {
        background: #f0f2ff;
        border-color: #764ba2;
        transform: translateY(-2px);
    }

    .upload-section.dragover {
        background: #e8ecff;
        border-color: #5a67d8;
    }

    .upload-icon {
        font-size: 4rem;
        color: #667eea;
        margin-bottom: 20px;
    }

    .file-input {
        display: none;
    }

    .upload-btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 15px 30px;
        border: none;
        border-radius: 50px;
        font-size: 1.1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        margin: 10px;
    }

    .upload-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
    }

    .settings-panel {
        background: #f8f9ff;
        border-radius: 15px;
        padding: 25px;
        margin: 20px 0;
        display: none;
    }

    .settings-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-top: 15px;
    }

    .setting-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .setting-group label {
        font-weight: 600;
        color: #374151;
    }

    .setting-group select, .setting-group input {
        padding: 10px 15px;
        border: 2px solid #e5e7eb;
        border-radius: 10px;
        font-size: 1rem;
        background: white;
    }

    .controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin: 30px 0;
        flex-wrap: wrap;
    }

    .control-btn {
        padding: 12px 25px;
        border: none;
        border-radius: 50px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 1rem;
    }

    .transcribe-btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
    }

    .stop-btn {
        background: #ef4444;
        color: white;
    }

    .control-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .control-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }

    .audio-info {
        background: #f8f9ff;
        padding: 20px;
        border-radius: 15px;
        margin: 20px 0;
        display: none;
    }

    .progress-container {
        margin: 20px 0;
        display: none;
    }

    .progress-bar {
        width: 100%;
        height: 12px;
        background: #e5e7eb;
        border-radius: 10px;
        overflow: hidden;
        position: relative;
    }

    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea, #764ba2);
        width: 0%;
        transition: width 0.3s ease;
    }

    .progress-segments {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
    }

    .progress-segment {
        flex: 1;
        border-right: 1px solid #fff;
        background: rgba(255, 255, 255, 0.1);
    }

    .progress-segment.completed {
        background: rgba(34, 197, 94, 0.3);
    }

    .progress-segment.processing {
        background: rgba(59, 130, 246, 0.3);
        animation: pulse 1.5s infinite;
    }

    .progress-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 10px;
        font-size: 0.9rem;
        color: #666;
    }

    .status {
        text-align: center;
        padding: 15px;
        margin: 20px 0;
        border-radius: 10px;
        font-weight: 600;
        display: none;
    }

    .status.processing {
        background: #dbeafe;
        color: #1e40af;
        border: 2px solid #3b82f6;
    }

    .status.completed {
        background: #dcfce7;
        color: #166534;
        border: 2px solid #22c55e;
    }

    .status.error {
        background: #fee2e2;
        color: #dc2626;
        border: 2px solid #ef4444;
    }

    .transcription-container {
        margin-top: 30px;
    }

    .transcription-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        flex-wrap: wrap;
        gap: 10px;
    }

    .transcription-header h3 {
        color: #374151;
        font-size: 1.3rem;
    }

    .export-buttons {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
    }

    .export-btn {
        background: #8b5cf6;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.3s ease;
        font-size: 0.9rem;
    }

    .export-btn:hover {
        background: #7c3aed;
        transform: translateY(-1px);
    }

    .export-btn.secondary {
        background: #6b7280;
    }

    .export-btn.secondary:hover {
        background: #4b5563;
    }

    .transcription-text {
        background: #ffffff;
        border: 2px solid #e5e7eb;
        border-radius: 15px;
        padding: 25px;
        min-height: 400px;
        font-size: 1.1rem;
        line-height: 1.8;
        color: #374151;
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.05);
        white-space: pre-wrap;
        overflow-y: auto;
        max-height: 600px;
    }

    .transcription-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 15px;
        margin-top: 15px;
        font-size: 0.9rem;
        color: #6b7280;
    }

    .stat-item {
        text-align: center;
        padding: 10px;
        background: #f9fafb;
        border-radius: 8px;
    }

    .stat-value {
        font-weight: 600;
        font-size: 1.1rem;
        color: #374151;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .processing-indicator {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 2px solid #3b82f6;
        border-radius: 50%;
        border-top-color: transparent;
        animation: spin 1s linear infinite;
        margin-right: 10px;
    }

    .chunk-progress {
        background: #f3f4f6;
        border-radius: 10px;
        padding: 15px;
        margin: 15px 0;
        display: none;
    }

    .chunk-info {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
        font-size: 0.9rem;
        color: #6b7280;
    }

    .chunk-bar {
        height: 6px;
        background: #e5e7eb;
        border-radius: 3px;
        overflow: hidden;
    }

    .chunk-fill {
        height: 100%;
        background: linear-gradient(90deg, #10b981, #059669);
        width: 0%;
        transition: width 0.3s ease;
    }

    @media (max-width: 768px) {
        .header h1 {
            font-size: 2rem;
        }
        
        .content {
            padding: 20px;
        }
        
        .settings-grid {
            grid-template-columns: 1fr;
        }
        
        .controls {
            flex-direction: column;
            align-items: center;
        }
        
        .control-btn {
            width: 200px;
        }
        
        .transcription-header {
            flex-direction: column;
            align-items: stretch;
        }
        
        .export-buttons {
            justify-content: center;
        }
    }
</style>
```

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Transcriptor Avanzado</h1>
            <p>Procesamiento r√°pido y silencioso de audios largos</p>
        </div>

```
    <div class="content">
        <!-- Secci√≥n de carga de archivo -->
        <div class="upload-section" id="uploadSection">
            <div class="upload-icon">üìÅ</div>
            <h3>Arrastra tu archivo de audio aqu√≠</h3>
            <p>Procesamiento optimizado para archios largos (MP3, WAV, M4A, OGG)</p>
            <input type="file" id="audioFile" class="file-input" accept="audio/*">
            <button class="upload-btn" onclick="document.getElementById('audioFile').click()">
                Seleccionar Archivo
            </button>
        </div>

        <!-- Panel de configuraci√≥n -->
        <div class="settings-panel" id="settingsPanel">
            <h4>‚öôÔ∏è Configuraci√≥n de Transcripci√≥n</h4>
            <div class="settings-grid">
                <div class="setting-group">
                    <label for="languageSelect">Idioma:</label>
                    <select id="languageSelect">
                        <option value="es-ES">Espa√±ol</option>
                        <option value="en-US">English</option>
                        <option value="fr-FR">Fran√ßais</option>
                        <option value="de-DE">Deutsch</option>
                        <option value="it-IT">Italiano</option>
                        <option value="pt-BR">Portugu√™s</option>
                        <option value="ja-JP">Êó•Êú¨Ë™û</option>
                        <option value="ko-KR">ÌïúÍµ≠Ïñ¥</option>
                        <option value="zh-CN">‰∏≠Êñá</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label for="qualitySelect">Calidad:</label>
                    <select id="qualitySelect">
                        <option value="high">Alta (m√°s lento)</option>
                        <option value="medium" selected>Media (recomendado)</option>
                        <option value="fast">R√°pida (menos precisa)</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label for="chunkSize">Tama√±o de segmento:</label>
                    <select id="chunkSize">
                        <option value="15">15 segundos</option>
                        <option value="30" selected>30 segundos</option>
                        <option value="60">60 segundos</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label for="overlapping">Solapamiento:</label>
                    <select id="overlapping">
                        <option value="0">Sin solapamiento</option>
                        <option value="2" selected>2 segundos</option>
                        <option value="5">5 segundos</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Informaci√≥n del archivo -->
        <div class="audio-info" id="audioInfo">
            <h4>üìä Informaci√≥n del archivo:</h4>
            <p id="fileName"></p>
            <p id="fileSize"></p>
            <p id="fileDuration"></p>
            <p id="estimatedTime"></p>
        </div>

        <!-- Barra de progreso -->
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
                <div class="progress-segments" id="progressSegments"></div>
            </div>
            <div class="progress-info">
                <span id="progressText">Preparando...</span>
                <span id="progressPercent">0%</span>
            </div>
        </div>

        <!-- Progreso de chunks -->
        <div class="chunk-progress" id="chunkProgress">
            <div class="chunk-info">
                <span id="chunkText">Procesando segmento...</span>
                <span id="chunkTime">00:00 / 00:00</span>
            </div>
            <div class="chunk-bar">
                <div class="chunk-fill" id="chunkFill"></div>
            </div>
        </div>

        <!-- Controles -->
        <div class="controls">
            <button class="control-btn transcribe-btn" id="transcribeBtn" onclick="startTranscription()" disabled>
                üéØ Iniciar Transcripci√≥n
            </button>
            <button class="control-btn stop-btn" id="stopBtn" onclick="stopTranscription()" disabled style="display: none;">
                ‚èπÔ∏è Detener
            </button>
        </div>

        <!-- Estado -->
        <div class="status" id="status"></div>

        <!-- Transcripci√≥n -->
        <div class="transcription-container" id="transcriptionContainer" style="display: none;">
            <div class="transcription-header">
                <h3>üìù Transcripci√≥n Completa</h3>
                <div class="export-buttons">
                    <button class="export-btn" onclick="exportTranscription('txt')">
                        üìÑ Exportar TXT
                    </button>
                    <button class="export-btn secondary" onclick="exportTranscription('srt')">
                        üé¨ Exportar SRT
                    </button>
                    <button class="export-btn secondary" onclick="copyToClipboard()">
                        üìã Copiar
                    </button>
                </div>
            </div>
            <div class="transcription-text" id="transcriptionText"></div>
            <div class="transcription-stats">
                <div class="stat-item">
                    <div class="stat-value" id="wordCount">0</div>
                    <div>Palabras</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="charCount">0</div>
                    <div>Caracteres</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="processTime">0</div>
                    <div>Tiempo (min)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="confidence">0%</div>
                    <div>Confianza</div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let audioFile = null;
    let audioContext = null;
    let audioBuffer = null;
    let isTranscribing = false;
    let transcriptionChunks = [];
    let currentChunk = 0;
    let totalChunks = 0;
    let startTime = null;
    let confidenceScores = [];

    // Inicializar eventos
    document.addEventListener('DOMContentLoaded', function() {
        const uploadSection = document.getElementById('uploadSection');
        const fileInput = document.getElementById('audioFile');

        // Drag and drop
        uploadSection.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', function(e) {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileSelect(files[0]);
            }
        });

        fileInput.addEventListener('change', function(e) {
            if (e.target.files.length > 0) {
                handleFileSelect(e.target.files[0]);
            }
        });

        // Verificar soporte para Web Speech API
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
            showStatus('error', '‚ùå Tu navegador no soporta reconocimiento de voz. Usa Chrome o Edge.');
        }
    });

    async function handleFileSelect(file) {
        if (!file.type.startsWith('audio/')) {
            showStatus('error', '‚ùå Por favor selecciona un archivo de audio v√°lido.');
            return;
        }

        audioFile = file;
        showStatus('processing', 'üîÑ Analizando archivo de audio...');
        
        try {
            await processAudioFile(file);
            showAudioInfo(file);
            document.getElementById('settingsPanel').style.display = 'block';
            enableTranscription();
            hideStatus();
        } catch (error) {
            showStatus('error', '‚ùå Error al procesar el archivo de audio.');
            console.error('Error:', error);
        }
    }

    async function processAudioFile(file) {
        // Inicializar AudioContext
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Leer el archivo como ArrayBuffer
        const arrayBuffer = await file.arrayBuffer();
        
        // Decodificar el audio
        audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
    }

    function showAudioInfo(file) {
        const audioInfo = document.getElementById('audioInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const fileDuration = document.getElementById('fileDuration');
        const estimatedTime = document.getElementById('estimatedTime');

        const duration = audioBuffer.duration;
        const chunkSize = parseInt(document.getElementById('chunkSize').value);
        const estimatedChunks = Math.ceil(duration / chunkSize);
        const estimatedMinutes = Math.ceil(estimatedChunks * 0.5); // Estimaci√≥n: 30s por chunk

        fileName.textContent = `üìÑ Nombre: ${file.name}`;
        fileSize.textContent = `üìè Tama√±o: ${formatFileSize(file.size)}`;
        fileDuration.textContent = `‚è±Ô∏è Duraci√≥n: ${formatTime(duration)}`;
        estimatedTime.textContent = `üöÄ Tiempo estimado: ${estimatedMinutes} min`;
        
        audioInfo.style.display = 'block';
    }

    function enableTranscription() {
        document.getElementById('transcribeBtn').disabled = false;
    }

    async function startTranscription() {
        if (isTranscribing) return;

        isTranscribing = true;
        startTime = Date.now();
        transcriptionChunks = [];
        currentChunk = 0;
        confidenceScores = [];

        // Actualizar UI
        document.getElementById('transcribeBtn').style.display = 'none';
        document.getElementById('stopBtn').style.display = 'inline-block';
        document.getElementById('stopBtn').disabled = false;
        document.getElementById('progressContainer').style.display = 'block';
        document.getElementById('chunkProgress').style.display = 'block';
        document.getElementById('transcriptionContainer').style.display = 'block';
        document.getElementById('transcriptionText').textContent = '';

        showStatus('processing', 'üöÄ Iniciando transcripci√≥n optimizada...');

        try {
            await processAudioInChunks();
        } catch (error) {
            showStatus('error', '‚ùå Error durante la transcripci√≥n.');
            console.error('Error:', error);
            stopTranscription();
        }
    }

    async function processAudioInChunks() {
        const chunkSize = parseInt(document.getElementById('chunkSize').value);
        const overlap = parseInt(document.getElementById('overlapping').value);
        const duration = audioBuffer.duration;
        
        // Calcular chunks
        const chunks = [];
        let currentTime = 0;
        
        while (currentTime < duration) {
            const endTime = Math.min(currentTime + chunkSize, duration);
            chunks.push({
                start: currentTime,
                end: endTime,
                duration: endTime - currentTime
            });
            currentTime = endTime - overlap;
        }

        totalChunks = chunks.length;
        
        // Crear segmentos visuales
        createProgressSegments(totalChunks);
        
        // Procesar cada chunk
        for (let i = 0; i < chunks.length && isTranscribing; i++) {
            currentChunk = i;
            const chunk = chunks[i];
            
            updateProgress(i, totalChunks);
            updateChunkProgress(chunk, i + 1, totalChunks);
            
            try {
                const audioBlob = await extractAudioChunk(chunk.start, chunk.end);
                const transcription = await transcribeAudioChunk(audioBlob, i);
                
                if (transcription && transcription.text.trim()) {
                    transcriptionChunks.push({
                        index: i,
                        start: chunk.start,
                        end: chunk.end,
                        text: transcription.text,
                        confidence: transcription.confidence
                    });
                    
                    confidenceScores.push(transcription.confidence);
                    updateTranscriptionDisplay();
                }
                
                // Marcar segmento como completado
                markSegmentCompleted(i);
                
                // Peque√±a pausa para no sobrecargar la API
                await new Promise(resolve => setTimeout(resolve, 100));
                
            } catch (error) {
                console.error(`Error en chunk ${i}:`, error);
                // Continuar con el siguiente chunk
            }
        }

        if (isTranscribing) {
            completeTranscription();
        }
    }

    async function extractAudioChunk(startTime, endTime) {
        const sampleRate = audioBuffer.sampleRate;
        const startSample = Math.floor(startTime * sampleRate);
        const endSample = Math.floor(endTime * sampleRate);
        const chunkLength = endSample - startSample;

        // Crear un nuevo AudioBuffer para el chunk
        const chunkBuffer = audioContext.createBuffer(
            audioBuffer.numberOfChannels,
            chunkLength,
            sampleRate
        );

        // Copiar los datos del chunk
        for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
            const channelData = audioBuffer.getChannelData(channel);
            const chunkData = chunkBuffer.getChannelData(channel);
            
            for (let i = 0; i < chunkLength; i++) {
                chunkData[i] = channelData[startSample + i];
            }
        }

        // Convertir a WAV Blob
        return audioBufferToWavBlob(chunkBuffer);
    }

    function audioBufferToWavBlob(buffer) {
        const length = buffer.length;
        const numberOfChannels = buffer.numberOfChannels;
        const sampleRate = buffer.sampleRate;
        const arrayBuffer = new ArrayBuffer(44 + length * numberOfChannels * 2);
        const view = new DataView(arrayBuffer);

        // WAV header
        const writeString = (offset, string) => {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };

        writeString(0, 'RIFF');
        view.setUint32(4, 36 + length * numberOfChannels * 2, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numberOfChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numberOfChannels * 2, true);
        view.setUint16(32, numberOfChannels * 2, true);
        view.setUint16(34, 16, true);
        writeString(36, 'data');
        view.setUint32(40, length * numberOfChannels * 2, true);

        // Audio data
        let offset = 44;
        for (let i = 0; i < length; i++) {
            for (let channel = 0; channel < numberOfChannels; channel++) {
                const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                offset += 2;
            }
        }

        return new Blob([arrayBuffer], { type: 'audio/wav' });
    }

    async function transcribeAudioChunk(audioBlob, chunkIndex) {
        return new Promise((resolve, reject) => {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            
            const selectedLanguage = document.getElementById('languageSelect').value;
            const quality = document.getElementById('qualitySelect').value;
            
            recognition.lang = selectedLanguage;
            recognition.continuous = true;
            recognition.interimResults = false;
            recognition.maxAlternatives = quality === 'high' ? 3 : 1;

            // Crear un audio temporal para la transcripci√≥n
            const audioUrl = URL.createObjectURL(audioBlob);
            const tempAudio = new Audio(audioUrl);
            tempAudio.volume = 0; // Silencioso
            
            let transcriptionResult = null;
            let hasResult = false;

            recognition.onresult = function(event) {
                if (event.results.length > 0) {
                    const result = event.results[event.results.length - 1];
                    if (result.isFinal) {
                        const transcript = result[0].transcript;
                        const confidence = result[0].confidence || 0.8;
                        
                        transcriptionResult = {
                            text: transcript,
                            confidence: confidence
                        };
                        hasResult = true;
                    }
                }
            };

            recognition.onerror = function(event) {
                console.error('Error en reconocimiento:', event.error);
                if (!hasResult) {
                    resolve({ text: '', confidence: 0 });
                }
            };

            recognition.onend = function() {
                URL.revokeObjectURL(audioUrl);
                if (hasResult && transcriptionResult) {
                    resolve(transcriptionResult);
                } else {
                    resolve({ text: '', confidence: 0 });
                }
            };

            // Iniciar reconocimiento
            recognition.start();
            
            // Reproducir audio silencioso para activar el reconocimiento
            tempAudio.play().then(() => {
                // Detener el reconocimiento cuando termine el audio
                tempAudio.addEventListener('ended', () => {
                    setTimeout(() => {
                        if (recognition && !hasResult) {
                            recognition.stop();
                        }
                    }, 1000);
                });
            }).catch(error => {
                console.error('Error al reproducir audio:', error);
                recognition.stop();
            });

            // Timeout de seguridad
            setTimeout(() => {
                if (!hasResult) {
                    recognition.stop();
                }
            }, 35000); // 35 segundos m√°ximo por chunk
        });
    }

    function createProgressSegments(totalChunks) {
        const segmentsContainer = document.getElementById('progressSegments');
        segmentsContainer.innerHTML = '';
        
        for (let i = 0; i < totalChunks; i++) {
            const segment = document.createElement('div');
            segment.className = 'progress-segment';
            segment.id = `segment-${i}`;
            segmentsContainer.appendChild(segment);
        }
    }

    function markSegmentCompleted(segmentIndex) {
        const segment = document.getElementById(`segment-${segmentIndex}`);
        if (segment) {
            segment.classList.add('completed');
        }
    }

    function updateProgress(current, total) {
        const percent = Math.round((current / total) * 100);
        document.getElementById('progressFill').style.width = percent + '%';
        document.getElementById('progressPercent').textContent = percent + '%';
        document.getElementById('progressText').textContent = 
            `Procesando segmento ${current + 1} de ${total}`;
    }

    function updateChunkProgress(chunk, current, total) {
        const chunkText = document.getElementById('chunkText');
        const chunkTime = document.getElementById('chunkTime');
        const chunkFill = document.getElementById('chunkFill');
        
        chunkText.textContent = `Segmento ${current}/${total} - Transcribiendo...`;
        chunkTime.textContent = `${formatTime(chunk.start)} - ${formatTime(chunk.end)}`;
        
        // Simular progreso del chunk
        let progress = 0;
        const interval = setInterval(() => {
            progress += 10;
            chunkFill.style.width = Math.min(progress, 95) + '%';
            
            if (progress >= 100) {
                clearInterval(interval);
            }
        }, 200);
    }

    function updateTranscriptionDisplay() {
        // Ordenar chunks por √≠ndice
        const sortedChunks = [...transcriptionChunks].sort((a, b) => a.index - b.index);
        
        // Combinar transcripciones
        let fullText = '';
        let previousEnd = 0;
        
        for (let i = 0; i < sortedChunks.length; i++) {
            const chunk = sortedChunks[i];
            
            // Agregar timestamp si hay un gap significativo
            if (chunk.start - previousEnd > 2) {
                fullText += `\n[${formatTime(chunk.start)}]\n`;
            }
            
            fullText += chunk.text;
            
            // Agregar espacio o salto de l√≠nea entre chunks
            if (i < sortedChunks.length - 1) {
                fullText += ' ';
            }
            
            previousEnd = chunk.end;
        }
        
        document.getElementById('transcriptionText').textContent = fullText;
        updateStats();
    }

    function updateStats() {
        const text = document.getElementById('transcriptionText').textContent;
        const words = text.trim().split(/\s+/).filter(word => word.length > 0);
        const chars = text.length;
        const elapsed = startTime ? Math.round((Date.now() - startTime) / 60000) : 0;
        const avgConfidence = confidenceScores.length > 0 ? 
            Math.round(confidenceScores.reduce((a, b) => a + b, 0) / confidenceScores.length * 100) : 0;
        
        document.getElementById('wordCount').textContent = words.length;
        document.getElementById('charCount').textContent = chars;
        document.getElementById('processTime').textContent = elapsed;
        document.getElementById('confidence').textContent = avgConfidence + '%';
    }

    function completeTranscription() {
        isTranscribing = false;
        
        document.getElementById('stopBtn').style.display = 'none';
        document.getElementById('transcribeBtn').style.display = 'inline-block';
        document.getElementById('transcribeBtn').disabled = false;
        document.getElementById('transcribeBtn').textContent = 'üîÑ Nueva Transcripci√≥n';
        
        document.getElementById('chunkProgress').style.display = 'none';
        document.getElementById('progressFill').style.width = '100%';
        document.getElementById('progressPercent').textContent = '100%';
        document.getElementById('progressText').textContent = 'Transcripci√≥n completada';
        
        showStatus('completed', '‚úÖ Transcripci√≥n completada exitosamente!');
        
        // Actualizar estad√≠sticas finales
        updateStats();
    }

    function stopTranscription() {
        isTranscribing = false;
        
        document.getElementById('stopBtn').style.display = 'none';
        document.getElementById('transcribeBtn').style.display = 'inline-block';
        document.getElementById('transcribeBtn').disabled = false;
        document.getElementById('transcribeBtn').textContent = 'üéØ Iniciar Transcripci√≥n';
        
        document.getElementById('chunkProgress').style.display = 'none';
        
        hideStatus();
    }

    function exportTranscription(format) {
        const text = document.getElementById('transcriptionText').textContent;
        if (!text.trim()) {
            showStatus('error', '‚ùå No hay transcripci√≥n para exportar.');
            return;
        }

        let content = '';
        let filename = '';
        let mimeType = '';

        if (format === 'txt') {
            content = text;
            filename = `transcripcion_${new Date().toISOString().split('T')[0]}.txt`;
            mimeType = 'text/plain;charset=utf-8';
        } else if (format === 'srt') {
            content = generateSRT();
            filename = `subtitulos_${new Date().toISOString().split('T')[0]}.srt`;
            mimeType = 'text/plain;charset=utf-8';
        }

        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showStatus('completed', `üíæ Archivo ${format.toUpperCase()} exportado exitosamente!`);
    }

    function generateSRT() {
        let srt = '';
        let counter = 1;
        
        for (const chunk of transcriptionChunks.sort((a, b) => a.index - b.index)) {
            const startTime = formatSRTTime(chunk.start);
            const endTime = formatSRTTime(chunk.end);
            const text = chunk.text.trim();
            
            if (text) {
                srt += `${counter}\n`;
                srt += `${startTime} --> ${endTime}\n`;
                srt += `${text}\n\n`;
                counter++;
            }
        }
        
        return srt;
    }

    function formatSRTTime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        const milliseconds = Math.floor((seconds % 1) * 1000);
        
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${milliseconds.toString().padStart(3, '0')}`;
    }

    async function copyToClipboard() {
        const text = document.getElementById('transcriptionText').textContent;
        if (!text.trim()) {
            showStatus('error', '‚ùå No hay transcripci√≥n para copiar.');
            return;
        }

        try {
            await navigator.clipboard.writeText(text);
            showStatus('completed', 'üìã Transcripci√≥n copiada al portapapeles!');
        } catch (err) {
            // Fallback para navegadores que no soportan clipboard API
            const textArea = document.createElement('textarea');
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            showStatus('completed', 'üìã Transcripci√≥n copiada al portapapeles!');
        }
    }

    function showStatus(type, message) {
        const status = document.getElementById('status');
        status.className = `status ${type}`;
        
        if (type === 'processing') {
            status.innerHTML = `<span class="processing-indicator"></span>${message}`;
        } else {
            status.textContent = message;
        }
        
        status.style.display = 'block';

        if (type === 'completed' || type === 'error') {
            setTimeout(hideStatus, 5000);
        }
    }

    function hideStatus() {
        document.getElementById('status').style.display = 'none';
    }

    function formatTime(seconds) {
        if (isNaN(seconds)) return '00:00';
        const hours = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        
        if (hours > 0) {
            return `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function formatFileSize(bytes) {
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        if (bytes === 0) return '0 Bytes';
        const i = Math.floor(Math.log(bytes) / Math.log(1024));
        return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
    }

    // Optimizaciones de rendimiento
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // Actualizar configuraci√≥n en tiempo real
    document.getElementById('chunkSize').addEventListener('change', function() {
        if (audioBuffer) {
            showAudioInfo(audioFile);
        }
    });

    // Limpiar recursos al cerrar
    window.addEventListener('beforeunload', function() {
        if (audioContext) {
            audioContext.close();
        }
    });
</script>
```

</body>
</html>
